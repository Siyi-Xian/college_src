/**
 * Tree interface and BinaryTree class from lec4b.
 */

public class BinaryTree implements Tree {

	class Node {
		int		data;
		Node	left, right;

		Node(int key) {
			this(key, null, null);
		}

		Node(int data, Node left, Node right) {
			this.data = data;
			this.left = left;
			this.right = right;
		}

		boolean isLeaf() {
			return left == null && right == null;
		}
	}

	Node	root;
	int		n;

	public void insert(int key) {
		n++;
		if (root == null)
			root = new Node(key);
		else if (root.left == null)
			root.left = new Node(key);
		else if (root.right == null)
			root.right = new Node(key);
		else if (Math.random() < 0.5)
			root = new Node(key, root, null);
		else
			root = new Node(key, null, root);
	}

	public boolean contains(int key) {
		return containsHelper(key, root);
	}

	private boolean containsHelper(int key, Node p) {
		if (p == null)
			return false;
		if (p.data == key)
			return true;
		return containsHelper(key, p.left) || containsHelper(key, p.right);
	}

	public int size() {
		return n;
	}
	
	private int findHeight(Node node, int key) {
		if (key == node.data)
			return 0;
		try {
			return (1 + this.findHeight(node.right, key));
		} catch (NullPointerException e) {
			return (1 + this.findHeight(node.left, key));
		}
	}
	
	public int height(int key) {
		if (this.contains(key))
			return this.findHeight(root, key);
		else
			throw new RuntimeException("The given key is not in the tree");
	}
}

interface Tree {
	void insert(int key);

	default void remove(int key) {
		throw new UnsupportedOperationException();
	}

	boolean contains(int key);

	int size();
	
	int height(int key);
	
	default boolean isEmpty() {
		return size() == 0;
	}
}
